# Домашнее задание к уроку 2


## Создаем таблицу в установленном внутри ВМ Postgres 16

    prince@l1vm:~$ sudo -u postgres psql
    psql (16.1 (Ubuntu 16.1-1.pgdg22.04+1))
    Введите "help", чтобы получить справку.

    postgres=# 
    
*Результат*
    
    postgres=# \l
                                                             Список баз данных
        Имя    | Владелец | Кодировка | Провайдер локали | LC_COLLATE  |  LC_CTYPE   | локаль ICU | Правила ICU |     Права доступа     
    -----------+----------+-----------+------------------+-------------+-------------+------------+-------------+-----------------------
     iso       | postgres | UTF8      | libc             | ru_RU.UTF-8 | ru_RU.UTF-8 |            |             | 
     postgres  | postgres | UTF8      | libc             | ru_RU.UTF-8 | ru_RU.UTF-8 |            |             | 
     template0 | postgres | UTF8      | libc             | ru_RU.UTF-8 | ru_RU.UTF-8 |            |             | =c/postgres          +
               |          |           |                  |             |             |            |             | postgres=CTc/postgres
     template1 | postgres | UTF8      | libc             | ru_RU.UTF-8 | ru_RU.UTF-8 |            |             | =c/postgres          +
               |          |           |                  |             |             |            |             | postgres=CTc/postgres
Команда 

    SELECT current_database(); 

показывает     **postgres**

Переходим в нужную 

    \с iso;

    iso=# SELECT current_database();
     current_database 
    ------------------
     iso
    (1 строка)

### Создаем таблицу

     i | amount 
    ---+--------
     1 |    100
     2 |    500
    (2 строки)

Уровень *transaction_isolation* по умолчанию уже   *read committed*

Включаем транзакцию с помощью **\\set AUTOCOMMIT OFF**

Переключаем разные варианты изоляции транзакций 

Коммитим.

Выключаем транзакцию.

##Пробуем как работает изоляции *read committed*.

При попытке ввода в одной из консолей потерялась точка с запятой и СУБД отказалась принимать дальнейшие команды до конца транзакции: "ОШИБКА:  текущая транзакция прервана, команды до конца блока транзакции игнорируются". Операция была переделана. 

Итого, до коммита в соседней сессии отобрадается прежнее значение, после коммита в соседней сессии (до коммита в "наблюдательной" сессии) - новое значение. 

    iso=*# SELECT * FROM test;
     i | amount 
    ---+--------
     2 |    500
     1 |    555
    (2 строки)

    iso=*# SELECT * FROM test;
     i | amount 
    ---+--------
     2 |    500
     1 |    666
    (2 строки)

##Пробуем *ISOLATION LEVEL SERIALIZABLE*

Результат операций во второй консоли: 

    iso=*# COMMIT;
    ОШИБКА:  не удалось сериализовать доступ из-за зависимостей чтения/записи между транзакциями
    ПОДРОБНОСТИ:  Reason code: Canceled on identification as a pivot, during commit attempt.    
    ПОДСКАЗКА:  Транзакция может завершиться успешно при следующей попытке.

Транзакция не может завершиться успешно, поскольку запрос 

    SELECT sum(amount) FROM testS WHERE i = 1;

затрагивает поля, измененные предыдущим запросом другой транзакции. Судя по сообщению, это действие изоляции именно на уровне сериализации.


